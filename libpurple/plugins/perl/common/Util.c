/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.16 from the
 * contents of Util.xs. Do not edit this file, edit Util.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Util.xs"
#include "module.h"

static void
purple_perl_util_url_cb(PurpleUtilFetchUrlData *url_data, void *user_data,
                        const gchar *url_text, size_t size,
                        const gchar *error_message)
{
	SV *sv = (SV *)user_data;
	dSP;
	ENTER;
	SAVETMPS;
	PUSHMARK(SP);

	XPUSHs(sv_2mortal(newSVpvn(url_text, size)));
	PUTBACK;

	call_sv(sv, G_EVAL | G_SCALAR);
	SPAGAIN;

	/* XXX Make sure this destroys it correctly and that we don't want
	 * something like sv_2mortal(sv) or something else here instead. */
	SvREFCNT_dec(sv);

	PUTBACK;
	FREETMPS;
	LEAVE;
}

static void markup_find_tag_foreach(GQuark key_id, char *data, HV *hv) {
	const char *key = NULL;
	key = g_quark_to_string(key_id);
	hv_store(hv, key, strlen(key), newSVpv(data, 0), 0);
}

#line 45 "Util.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 187 "Util.c"

XS_EUPXS(XS_Purple__Util_running_gnome); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_running_gnome)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	gboolean	RETVAL;

	RETVAL = purple_running_gnome();
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_running_kde); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_running_kde)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	gboolean	RETVAL;

	RETVAL = purple_running_kde();
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_running_osx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_running_osx)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	gboolean	RETVAL;

	RETVAL = purple_running_osx();
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_build_dir); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_build_dir)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "path, mode");
    {
	const char *	path = (const char *)SvPV_nolen(ST(0))
;
	int	mode = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = purple_build_dir(path, mode);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_email_is_valid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_email_is_valid)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "address");
    {
	const char *	address = (const char *)SvPV_nolen(ST(0))
;
	gboolean	RETVAL;

	RETVAL = purple_email_is_valid(address);
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_escape_filename); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_escape_filename)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "str");
    {
	const char *	str = (const char *)SvPV_nolen(ST(0))
;
	const char *	RETVAL;
	dXSTARG;

	RETVAL = purple_escape_filename(str);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_fd_get_ip); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_fd_get_ip)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fd");
    {
	int	fd = (int)SvIV(ST(0))
;
	gchar_own *	RETVAL;

	RETVAL = purple_fd_get_ip(fd);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_home_dir); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_home_dir)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	const gchar *	RETVAL;
	dXSTARG;

	RETVAL = purple_home_dir();
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_message_meify); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_message_meify)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "msg");
    {
#line 70 "Util.xs"
		char *message = NULL;
		gboolean ret;
		gsize len;
#line 351 "Util.c"
	gchar_own *	RETVAL;
	SV *	msg = ST(0)
;
#line 74 "Util.xs"
		message = SvPV(msg, len);
		message = g_strndup(message, len);
		ret = purple_message_meify(message, len);
		if(ret) {
			/* message will get g_free()'d later on, since RETVAL is gchar_own* */
			RETVAL = message;
		} else {
			RETVAL = NULL;
			g_free(message);
		}
#line 366 "Util.c"
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_mkstemp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_mkstemp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "binary");
    {
	gboolean	binary = (bool)SvTRUE(ST(0))
;
	FILE *	RETVAL;
	gchar_own *	path;

	RETVAL = purple_mkstemp(&path, binary);
	ST(0) = sv_newmortal();
	{
	    GV *gv = newGVgen("Purple::Util");
	    PerlIO *fp = PerlIO_importFILE(RETVAL,0);
	    if ( fp && do_open(gv, "+<&", 3, FALSE, 0, 0, fp) )
		sv_setsv(ST(0), sv_bless(newRV((SV*)gv), gv_stashpv("Purple::Util",1)));
	    else
		ST(0) = &PL_sv_undef;
	}
	XSprePUSH;	EXTEND(SP,1);
	PUSHs(sv_newmortal());
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(1), path);
	SvUTF8_on (ST(1));
	g_free (path);
    }
    XSRETURN(2);
}


XS_EUPXS(XS_Purple__Util_normalize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_normalize)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "account, str");
    {
	Purple__Account	account = purple_perl_ref_object(ST(0))
;
	const char *	str = (const char *)SvPV_nolen(ST(1))
;
	const char *	RETVAL;
	dXSTARG;

	RETVAL = purple_normalize(account, str);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_program_is_valid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_program_is_valid)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "program");
    {
	const char *	program = (const char *)SvPV_nolen(ST(0))
;
	gboolean	RETVAL;

	RETVAL = purple_program_is_valid(program);
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_strdup_withhtml); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_strdup_withhtml)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "src");
    {
	const gchar *	src = (const gchar *)SvPV_nolen(ST(0))
;
	gchar_own *	RETVAL;

	RETVAL = purple_strdup_withhtml(src);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_text_strip_mnemonic); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_text_strip_mnemonic)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "in");
    {
	const char *	in = (const char *)SvPV_nolen(ST(0))
;
	gchar_own *	RETVAL;

	RETVAL = purple_text_strip_mnemonic(in);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_time_build); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_time_build)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "year, month, day, hour, min, sec");
    {
	int	year = (int)SvIV(ST(0))
;
	int	month = (int)SvIV(ST(1))
;
	int	day = (int)SvIV(ST(2))
;
	int	hour = (int)SvIV(ST(3))
;
	int	min = (int)SvIV(ST(4))
;
	int	sec = (int)SvIV(ST(5))
;
	time_t	RETVAL;
	dXSTARG;

	RETVAL = purple_time_build(year, month, day, hour, min, sec);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_time_format); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_time_format)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "tm");
    {
	const struct tm *	tm = INT2PTR(const struct tm *,SvIV(ST(0)))
;
	const char *	RETVAL;
	dXSTARG;

	RETVAL = purple_time_format(tm);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_unescape_filename); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_unescape_filename)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "str");
    {
	const char *	str = (const char *)SvPV_nolen(ST(0))
;
	const char *	RETVAL;
	dXSTARG;

	RETVAL = purple_unescape_filename(str);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_unescape_html); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_unescape_html)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "html");
    {
	const char *	html = (const char *)SvPV_nolen(ST(0))
;
	gchar_own *	RETVAL;

	RETVAL = purple_unescape_html(html);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_url_decode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_url_decode)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "str");
    {
	const char *	str = (const char *)SvPV_nolen(ST(0))
;
	const char *	RETVAL;
	dXSTARG;

	RETVAL = purple_url_decode(str);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_url_encode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_url_encode)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "str");
    {
	const char *	str = (const char *)SvPV_nolen(ST(0))
;
	const char *	RETVAL;
	dXSTARG;

	RETVAL = purple_url_encode(str);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_url_parse); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_url_parse)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "url");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	const char *	url = (const char *)SvPV_nolen(ST(0))
;
#line 149 "Util.xs"
		char *ret_host;
		int ret_port;
		char *ret_path;
		char *ret_user;
		char *ret_passwd;
		gboolean ret;
#line 649 "Util.c"
#line 156 "Util.xs"
		ret = purple_url_parse(url, &ret_host, &ret_port, &ret_path, &ret_user, &ret_passwd);
		XPUSHs(sv_2mortal(newSViv(ret)));
		XPUSHs(ret_host ? sv_2mortal(newSVpv(ret_host, 0)) : sv_2mortal(newSV(0)));
		XPUSHs(sv_2mortal(newSViv(ret_port)));
		XPUSHs(ret_path ? sv_2mortal(newSVpv(ret_path, 0)) : sv_2mortal(newSV(0)));
		XPUSHs(ret_user ? sv_2mortal(newSVpv(ret_user, 0)) : sv_2mortal(newSV(0)));
		XPUSHs(ret_passwd ? sv_2mortal(newSVpv(ret_passwd, 0)) : sv_2mortal(newSV(0)));
		g_free(ret_host);
		g_free(ret_path);
		g_free(ret_user);
		g_free(ret_passwd);
#line 662 "Util.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Purple__Util_user_dir); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_user_dir)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	const char *	RETVAL;
	dXSTARG;

	RETVAL = purple_user_dir();
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_utf8_strftime); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_utf8_strftime)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "format, tm");
    {
	const char *	RETVAL;
	dXSTARG;
	const char *	format = (const char *)SvPV_nolen(ST(0))
;
	const struct tm *	tm = INT2PTR(const struct tm *,SvIV(ST(1)))
;

	RETVAL = purple_utf8_strftime(format, tm);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_utf8_has_word); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_utf8_has_word)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "haystack, needle");
    {
	const char*	haystack = (const char *)SvPV_nolen(ST(0))
;
	const char*	needle = (const char *)SvPV_nolen(ST(1))
;
	gboolean	RETVAL;

	RETVAL = purple_utf8_has_word(haystack, needle);
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_utf8_ncr_decode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_utf8_ncr_decode)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "in");
    {
	const char*	in = (const char *)SvPV_nolen(ST(0))
;
	gchar_own *	RETVAL;

	RETVAL = purple_utf8_ncr_decode(in);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_utf8_ncr_encode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_utf8_ncr_encode)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "in");
    {
	const char*	in = (const char *)SvPV_nolen(ST(0))
;
	gchar_own *	RETVAL;

	RETVAL = purple_utf8_ncr_encode(in);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_utf8_salvage); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_utf8_salvage)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "str");
    {
	const char*	str = (const char *)SvPV_nolen(ST(0))
;
	gchar_own *	RETVAL;

	RETVAL = purple_utf8_salvage(str);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_utf8_strcasecmp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_utf8_strcasecmp)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "a, b");
    {
	const char*	a = (const char *)SvPV_nolen(ST(0))
;
	const char*	b = (const char *)SvPV_nolen(ST(1))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = purple_utf8_strcasecmp(a, b);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_utf8_try_convert); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_utf8_try_convert)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "str");
    {
	const char*	str = (const char *)SvPV_nolen(ST(0))
;
	gchar_own *	RETVAL;

	RETVAL = purple_utf8_try_convert(str);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_ip_address_is_valid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_ip_address_is_valid)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ip");
    {
	const char*	ip = (const char *)SvPV_nolen(ST(0))
;
	gboolean	RETVAL;

	RETVAL = purple_ip_address_is_valid(ip);
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_normalize_nocase); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_normalize_nocase)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "account, str");
    {
	Purple__Account	account = purple_perl_ref_object(ST(0))
;
	const char*	str = (const char *)SvPV_nolen(ST(1))
;
	const char *	RETVAL;
	dXSTARG;

	RETVAL = purple_normalize_nocase(account, str);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_gai_strerror); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_gai_strerror)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "errnum");
    {
	gint	errnum = (gint)SvIV(ST(0))
;
	const gchar *	RETVAL;
	dXSTARG;

	RETVAL = purple_gai_strerror(errnum);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_got_protocol_handler_uri); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_got_protocol_handler_uri)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "uri");
    {
	const char*	uri = (const char *)SvPV_nolen(ST(0))
;

	purple_got_protocol_handler_uri(uri);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Purple__Util_base16_encode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_base16_encode)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "data");
    {
	gchar_own *	RETVAL;
	STRLEN	STRLEN_length_of_data;
	gsize	XSauto_length_of_data;
	const guchar *	data = (const guchar *)SvPV(ST(0), STRLEN_length_of_data);

	XSauto_length_of_data = STRLEN_length_of_data;

	RETVAL = purple_base16_encode(data, XSauto_length_of_data);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_base16_encode_chunked); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_base16_encode_chunked)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "data");
    {
	gchar_own *	RETVAL;
	STRLEN	STRLEN_length_of_data;
	gsize	XSauto_length_of_data;
	const guchar *	data = (const guchar *)SvPV(ST(0), STRLEN_length_of_data);

	XSauto_length_of_data = STRLEN_length_of_data;

	RETVAL = purple_base16_encode_chunked(data, XSauto_length_of_data);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_base64_encode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_base64_encode)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "data");
    {
	gchar_own *	RETVAL;
	STRLEN	STRLEN_length_of_data;
	gsize	XSauto_length_of_data;
	const guchar *	data = (const guchar *)SvPV(ST(0), STRLEN_length_of_data);

	XSauto_length_of_data = STRLEN_length_of_data;

	RETVAL = purple_base64_encode(data, XSauto_length_of_data);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_restore_default_signal_handlers); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_restore_default_signal_handlers)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	purple_restore_default_signal_handlers();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Purple__Util_base16_decode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_base16_decode)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "str");
    {
	const char*	str = (const char *)SvPV_nolen(ST(0))
;
#line 237 "Util.xs"
	gsize len;
	guchar *ret;
#line 1027 "Util.c"
	SV *	RETVAL;
#line 240 "Util.xs"
		ret = purple_base16_decode(str, &len);
		if(ret && len > 0) {
			RETVAL = newSVpv((gchar *)ret, len);
		} else {
			g_free(ret);
			XSRETURN_UNDEF;
		}
		g_free(ret);
#line 1038 "Util.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_base64_decode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_base64_decode)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "str");
    {
	const char*	str = (const char *)SvPV_nolen(ST(0))
;
#line 255 "Util.xs"
	gsize len;
	guchar *ret;
#line 1058 "Util.c"
	SV *	RETVAL;
#line 258 "Util.xs"
		ret = purple_base64_decode(str, &len);
		if(ret && len > 0) {
			RETVAL = newSVpv((gchar *)ret, len);
		} else {
			g_free(ret);
			XSRETURN_UNDEF;
		}
		g_free(ret);
#line 1069 "Util.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_quotedp_decode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_quotedp_decode)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "str");
    {
	const char*	str = (const char *)SvPV_nolen(ST(0))
;
#line 273 "Util.xs"
	gsize len;
	guchar *ret;
#line 1089 "Util.c"
	SV *	RETVAL;
#line 276 "Util.xs"
		ret = purple_quotedp_decode(str, &len);
		if(len) {
			RETVAL = newSVpv((gchar *)ret, len);
		} else {
			g_free(ret);
			XSRETURN_UNDEF;
		}
		g_free(ret);
#line 1100 "Util.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_uri_list_extract_uris); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_uri_list_extract_uris)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "uri_list");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	const gchar*	uri_list = (const gchar *)SvPV_nolen(ST(0))
;
#line 291 "Util.xs"
		GList *l = NULL, *gl = NULL;
#line 1121 "Util.c"
#line 293 "Util.xs"
		gl = purple_uri_list_extract_uris(uri_list);
		for(l = gl; l; l = l->next) {
			XPUSHs(sv_2mortal(newSVpv(l->data, 0)));
			g_free(l->data);
		}
		g_list_free(gl);
#line 1129 "Util.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Purple__Util_uri_list_extract_filenames); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_uri_list_extract_filenames)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "uri_list");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	const gchar*	uri_list = (const gchar *)SvPV_nolen(ST(0))
;
#line 304 "Util.xs"
		GList *l = NULL, *gl = NULL;
#line 1149 "Util.c"
#line 306 "Util.xs"
		gl = purple_uri_list_extract_filenames(uri_list);
		for(l = gl; l; l = l->next) {
			XPUSHs(sv_2mortal(newSVpv(l->data, 0)));
			g_free(l->data);
		}
		g_list_free(gl);
#line 1157 "Util.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Purple__Util__Str_add_cr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util__Str_add_cr)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "str");
    {
	const char *	str = (const char *)SvPV_nolen(ST(0))
;
	gchar_own *	RETVAL;

	RETVAL = purple_str_add_cr(str);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util__Str_binary_to_ascii); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util__Str_binary_to_ascii)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "binary");
    {
	gchar_own *	RETVAL;
	STRLEN	STRLEN_length_of_binary;
	guint	XSauto_length_of_binary;
	const unsigned char *	binary = (const unsigned char *)SvPV(ST(0), STRLEN_length_of_binary);

	XSauto_length_of_binary = STRLEN_length_of_binary;

	RETVAL = purple_str_binary_to_ascii(binary, XSauto_length_of_binary);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util__Str_has_prefix); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util__Str_has_prefix)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "s, p");
    {
	const char *	s = (const char *)SvPV_nolen(ST(0))
;
	const char *	p = (const char *)SvPV_nolen(ST(1))
;
	gboolean	RETVAL;

	RETVAL = purple_str_has_prefix(s, p);
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util__Str_has_suffix); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util__Str_has_suffix)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "s, x");
    {
	const char *	s = (const char *)SvPV_nolen(ST(0))
;
	const char *	x = (const char *)SvPV_nolen(ST(1))
;
	gboolean	RETVAL;

	RETVAL = purple_str_has_suffix(s, x);
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util__Str_seconds_to_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util__Str_seconds_to_string)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sec");
    {
	guint	sec = (guint)SvIV(ST(0))
;
	gchar_own *	RETVAL;

	RETVAL = purple_str_seconds_to_string(sec);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util__Str_size_to_units); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util__Str_size_to_units)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "size");
    {
	size_t	size = (size_t)SvUV(ST(0))
;
	gchar_own *	RETVAL;

	RETVAL = purple_str_size_to_units(size);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util__Str_to_time); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util__Str_to_time)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "timestamp, utc = FALSE, tm = NULL");
    {
	const char *	timestamp = (const char *)SvPV_nolen(ST(0))
;
	gboolean	utc;
	struct tm *	tm;
	time_t	RETVAL;
	dXSTARG;
	long	tz_off;
	const char *	rest;

	if (items < 2)
	    utc = FALSE;
	else {
	    utc = (bool)SvTRUE(ST(1))
;
	}

	if (items < 3)
	    tm = NULL;
	else {
	    tm = INT2PTR(struct tm *,SvIV(ST(2)))
;
	}

	RETVAL = purple_str_to_time(timestamp, utc, tm, &tz_off, &rest);
	XSprePUSH; PUSHi((IV)RETVAL);
	EXTEND(SP,2);
	PUSHs(sv_newmortal());
	sv_setiv(ST(1), (IV)tz_off);
	PUSHs(sv_newmortal());
	sv_setpv((SV*)ST(2), rest);
    }
    XSRETURN(3);
}


XS_EUPXS(XS_Purple__Util__Date_format_full); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util__Date_format_full)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "tm");
    {
	const struct tm *	tm = INT2PTR(const struct tm *,SvIV(ST(0)))
;
	const char *	RETVAL;
	dXSTARG;

	RETVAL = purple_date_format_full(tm);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util__Date_format_long); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util__Date_format_long)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "tm");
    {
	const struct tm *	tm = INT2PTR(const struct tm *,SvIV(ST(0)))
;
	const char *	RETVAL;
	dXSTARG;

	RETVAL = purple_date_format_long(tm);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util__Date_format_short); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util__Date_format_short)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "tm");
    {
	const struct tm *	tm = INT2PTR(const struct tm *,SvIV(ST(0)))
;
	const char *	RETVAL;
	dXSTARG;

	RETVAL = purple_date_format_short(tm);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util__Markup_extract_info_field); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util__Markup_extract_info_field)
{
    dVAR; dXSARGS;
    if (items != 12)
       croak_xs_usage(cv,  "str, len, user_info, start_token, skip, end_token, check_value, no_value_token, display_name, is_link, link_prefix, format_cb");
    {
	const char *	str = (const char *)SvPV_nolen(ST(0))
;
	int	len = (int)SvIV(ST(1))
;
	Purple__NotifyUserInfo	user_info = purple_perl_ref_object(ST(2))
;
	const char *	start_token = (const char *)SvPV_nolen(ST(3))
;
	int	skip = (int)SvIV(ST(4))
;
	const char *	end_token = (const char *)SvPV_nolen(ST(5))
;
	char	check_value = (char)*SvPV_nolen(ST(6))
;
	const char *	no_value_token = (const char *)SvPV_nolen(ST(7))
;
	const char *	display_name = (const char *)SvPV_nolen(ST(8))
;
	gboolean	is_link = (bool)SvTRUE(ST(9))
;
	const char *	link_prefix = (const char *)SvPV_nolen(ST(10))
;
	Purple__Util__InfoFieldFormatCallback	format_cb = INT2PTR(Purple__Util__InfoFieldFormatCallback,SvIV(ST(11)))
;
	gboolean	RETVAL;

	RETVAL = purple_markup_extract_info_field(str, len, user_info, start_token, skip, end_token, check_value, no_value_token, display_name, is_link, link_prefix, format_cb);
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util__Markup_find_tag); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util__Markup_find_tag)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "needle, haystack");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	const char *	needle = (const char *)SvPV_nolen(ST(0))
;
	const char *	haystack = (const char *)SvPV_nolen(ST(1))
;
#line 389 "Util.xs"
		const char *start = NULL;
		const char *end = NULL;
		GData *attributes;
		gboolean ret;
		HV *hv = NULL;
#line 1464 "Util.c"
#line 395 "Util.xs"
		ret = purple_markup_find_tag(needle, haystack, &start, &end, &attributes);
		if(!ret) XSRETURN_UNDEF;

		hv = newHV();
		g_datalist_foreach(&attributes, (GDataForeachFunc) markup_find_tag_foreach, hv);
		g_datalist_clear(&attributes);

		XPUSHs(sv_2mortal(newSVpv(start, 0)));
		XPUSHs(sv_2mortal(newSVpv(end, 0)));
		XPUSHs(sv_2mortal(newRV_noinc((SV *) hv)));
#line 1476 "Util.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Purple__Util__Markup_get_tag_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util__Markup_get_tag_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "tag");
    {
	const char *	tag = (const char *)SvPV_nolen(ST(0))
;
	gchar_own *	RETVAL;

	RETVAL = purple_markup_get_tag_name(tag);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util__Markup_html_to_xhtml); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util__Markup_html_to_xhtml)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "html");
    {
	const char *	html = (const char *)SvPV_nolen(ST(0))
;
	gchar_own *	dest_xhtml;
	gchar_own *	dest_plain;

	purple_markup_html_to_xhtml(html, &dest_xhtml, &dest_plain);
	XSprePUSH;	EXTEND(SP,2);
	PUSHs(sv_newmortal());
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), dest_xhtml);
	SvUTF8_on (ST(0));
	g_free (dest_xhtml);
	PUSHs(sv_newmortal());
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(1), dest_plain);
	SvUTF8_on (ST(1));
	g_free (dest_plain);
    }
    XSRETURN(2);
}


XS_EUPXS(XS_Purple__Util__Markup_linkify); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util__Markup_linkify)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "str");
    {
	const char *	str = (const char *)SvPV_nolen(ST(0))
;
	gchar_own *	RETVAL;

	RETVAL = purple_markup_linkify(str);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util__Markup_slice); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util__Markup_slice)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "str, x, y");
    {
	const char *	str = (const char *)SvPV_nolen(ST(0))
;
	guint	x = (guint)SvIV(ST(1))
;
	guint	y = (guint)SvIV(ST(2))
;
	gchar_own *	RETVAL;

	RETVAL = purple_markup_slice(str, x, y);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util__Markup_strip_html); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util__Markup_strip_html)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "str");
    {
	const char *	str = (const char *)SvPV_nolen(ST(0))
;
	gchar_own *	RETVAL;

	RETVAL = purple_markup_strip_html(str);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util__Markup_get_css_property); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util__Markup_get_css_property)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "style, opt");
    {
	const gchar*	style = (const gchar *)SvPV_nolen(ST(0))
;
	const gchar*	opt = (const gchar *)SvPV_nolen(ST(1))
;
	gchar_own *	RETVAL;

	RETVAL = purple_markup_get_css_property(style, opt);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util__Markup_unescape_entity); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util__Markup_unescape_entity)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "text");
    {
	const char*	text = (const char *)SvPV_nolen(ST(0))
;
#line 438 "Util.xs"
	int length;
#line 1653 "Util.c"
	SV *	RETVAL;
#line 440 "Util.xs"
		{
			const char *str = purple_markup_unescape_entity(text, &length);
			if(length) {
				RETVAL = newSVpv(str, length);
			} else {
				XSRETURN_UNDEF;
			}
		}
#line 1664 "Util.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_fetch_url); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_fetch_url)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "plugin, url, full, user_agent, http11, cb");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Purple__Plugin	plugin = purple_perl_ref_object(ST(0))
;
	const char *	url = (const char *)SvPV_nolen(ST(1))
;
	gboolean	full = (bool)SvTRUE(ST(2))
;
	const char *	user_agent = (const char *)SvPV_nolen(ST(3))
;
	gboolean	http11 = (bool)SvTRUE(ST(4))
;
	SV *	cb = ST(5)
;
#line 465 "Util.xs"
	PurpleUtilFetchUrlData *data;
#line 1695 "Util.c"
#line 467 "Util.xs"
	/* XXX: i don't like this... only plugins can use it... */
	SV *sv = purple_perl_sv_from_fun(plugin, cb);

	if (sv != NULL) {
		data = purple_util_fetch_url(url, full, user_agent, http11,
		                      purple_perl_util_url_cb, sv);
		XPUSHs(sv_2mortal(purple_perl_bless_object(data, "Purple::Util::FetchUrlData")));
	} else {
		purple_debug_warning("perl", "Callback not a valid type, only strings and coderefs allowed in purple_util_fetch_url.\n");
		XSRETURN_UNDEF;
	}
#line 1708 "Util.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Purple__Util_set_user_dir); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_set_user_dir)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dir");
    {
	const char *	dir = (const char *)SvPV_nolen(ST(0))
;

	purple_util_set_user_dir(dir);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Purple__Util_write_data_to_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_write_data_to_file)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "filename, data");
    {
	const char *	filename = (const char *)SvPV_nolen(ST(0))
;
	gboolean	RETVAL;
	STRLEN	STRLEN_length_of_data;
	size_t	XSauto_length_of_data;
	const char *	data = (const char *)SvPV(ST(1), STRLEN_length_of_data);

	XSauto_length_of_data = STRLEN_length_of_data;

	RETVAL = purple_util_write_data_to_file(filename, data, XSauto_length_of_data);
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_set_current_song); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_set_current_song)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "title, artist, album");
    {
	const char *	title = (const char *)SvPV_nolen(ST(0))
;
	const char *	artist = (const char *)SvPV_nolen(ST(1))
;
	const char *	album = (const char *)SvPV_nolen(ST(2))
;

	purple_util_set_current_song(title, artist, album);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Purple__Util_format_song_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_format_song_info)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "title, artist, album, unused");
    {
	const char*	title = (const char *)SvPV_nolen(ST(0))
;
	const char*	artist = (const char *)SvPV_nolen(ST(1))
;
	const char*	album = (const char *)SvPV_nolen(ST(2))
;
	gpointer	unused = purple_perl_ref_object(ST(3))
;
	gchar_own *	RETVAL;

	RETVAL = purple_util_format_song_info(title, artist, album, unused);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_get_image_extension); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_get_image_extension)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "data");
    {
	const char *	RETVAL;
	dXSTARG;
	STRLEN	STRLEN_length_of_data;
	size_t	XSauto_length_of_data;
	const char *	data = (const char *)SvPV(ST(0), STRLEN_length_of_data);

	XSauto_length_of_data = STRLEN_length_of_data;

	RETVAL = purple_util_get_image_extension(data, XSauto_length_of_data);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_get_image_filename); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_get_image_filename)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "image_data");
    {
	gchar_own *	RETVAL;
	STRLEN	STRLEN_length_of_image_data;
	size_t	XSauto_length_of_image_data;
	const char *	image_data = (const char *)SvPV(ST(0), STRLEN_length_of_image_data);

	XSauto_length_of_image_data = STRLEN_length_of_image_data;

	RETVAL = purple_util_get_image_filename(image_data, XSauto_length_of_image_data);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_read_xml_from_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_read_xml_from_file)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "filename, description");
    {
	const char*	filename = (const char *)SvPV_nolen(ST(0))
;
	const char*	description = (const char *)SvPV_nolen(ST(1))
;
	Purple__XMLNode	RETVAL;

	RETVAL = purple_util_read_xml_from_file(filename, description);
	ST(0) = purple_perl_bless_object(RETVAL, "Purple::XMLNode");
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Purple__Util_write_data_to_file_absolute); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Purple__Util_write_data_to_file_absolute)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "filename_full, data");
    {
	const char*	filename_full = (const char *)SvPV_nolen(ST(0))
;
	gboolean	RETVAL;
	STRLEN	STRLEN_length_of_data;
	gssize	XSauto_length_of_data;
	char *	data = (char *)SvPV(ST(1), STRLEN_length_of_data);

	XSauto_length_of_data = STRLEN_length_of_data;

	RETVAL = purple_util_write_data_to_file_absolute(filename_full, data, XSauto_length_of_data);
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Purple__Util); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Purple__Util)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        (void)newXSproto_portable("Purple::Util::running_gnome", XS_Purple__Util_running_gnome, file, "");
        (void)newXSproto_portable("Purple::Util::running_kde", XS_Purple__Util_running_kde, file, "");
        (void)newXSproto_portable("Purple::Util::running_osx", XS_Purple__Util_running_osx, file, "");
        (void)newXSproto_portable("Purple::Util::build_dir", XS_Purple__Util_build_dir, file, "$$");
        (void)newXSproto_portable("Purple::Util::email_is_valid", XS_Purple__Util_email_is_valid, file, "$");
        (void)newXSproto_portable("Purple::Util::escape_filename", XS_Purple__Util_escape_filename, file, "$");
        (void)newXSproto_portable("Purple::Util::fd_get_ip", XS_Purple__Util_fd_get_ip, file, "$");
        (void)newXSproto_portable("Purple::Util::home_dir", XS_Purple__Util_home_dir, file, "");
        (void)newXSproto_portable("Purple::Util::message_meify", XS_Purple__Util_message_meify, file, "$");
        (void)newXSproto_portable("Purple::Util::mkstemp", XS_Purple__Util_mkstemp, file, "$");
        (void)newXSproto_portable("Purple::Util::normalize", XS_Purple__Util_normalize, file, "$$");
        (void)newXSproto_portable("Purple::Util::program_is_valid", XS_Purple__Util_program_is_valid, file, "$");
        (void)newXSproto_portable("Purple::Util::strdup_withhtml", XS_Purple__Util_strdup_withhtml, file, "$");
        (void)newXSproto_portable("Purple::Util::text_strip_mnemonic", XS_Purple__Util_text_strip_mnemonic, file, "$");
        (void)newXSproto_portable("Purple::Util::time_build", XS_Purple__Util_time_build, file, "$$$$$$");
        (void)newXSproto_portable("Purple::Util::time_format", XS_Purple__Util_time_format, file, "$");
        (void)newXSproto_portable("Purple::Util::unescape_filename", XS_Purple__Util_unescape_filename, file, "$");
        (void)newXSproto_portable("Purple::Util::unescape_html", XS_Purple__Util_unescape_html, file, "$");
        (void)newXSproto_portable("Purple::Util::url_decode", XS_Purple__Util_url_decode, file, "$");
        (void)newXSproto_portable("Purple::Util::url_encode", XS_Purple__Util_url_encode, file, "$");
        (void)newXSproto_portable("Purple::Util::url_parse", XS_Purple__Util_url_parse, file, "$");
        (void)newXSproto_portable("Purple::Util::user_dir", XS_Purple__Util_user_dir, file, "");
        (void)newXSproto_portable("Purple::Util::utf8_strftime", XS_Purple__Util_utf8_strftime, file, "$$");
        (void)newXSproto_portable("Purple::Util::utf8_has_word", XS_Purple__Util_utf8_has_word, file, "$$");
        (void)newXSproto_portable("Purple::Util::utf8_ncr_decode", XS_Purple__Util_utf8_ncr_decode, file, "$");
        (void)newXSproto_portable("Purple::Util::utf8_ncr_encode", XS_Purple__Util_utf8_ncr_encode, file, "$");
        (void)newXSproto_portable("Purple::Util::utf8_salvage", XS_Purple__Util_utf8_salvage, file, "$");
        (void)newXSproto_portable("Purple::Util::utf8_strcasecmp", XS_Purple__Util_utf8_strcasecmp, file, "$$");
        (void)newXSproto_portable("Purple::Util::utf8_try_convert", XS_Purple__Util_utf8_try_convert, file, "$");
        (void)newXSproto_portable("Purple::Util::ip_address_is_valid", XS_Purple__Util_ip_address_is_valid, file, "$");
        (void)newXSproto_portable("Purple::Util::normalize_nocase", XS_Purple__Util_normalize_nocase, file, "$$");
        (void)newXSproto_portable("Purple::Util::gai_strerror", XS_Purple__Util_gai_strerror, file, "$");
        (void)newXSproto_portable("Purple::Util::got_protocol_handler_uri", XS_Purple__Util_got_protocol_handler_uri, file, "$");
        (void)newXSproto_portable("Purple::Util::base16_encode", XS_Purple__Util_base16_encode, file, "$");
        (void)newXSproto_portable("Purple::Util::base16_encode_chunked", XS_Purple__Util_base16_encode_chunked, file, "$");
        (void)newXSproto_portable("Purple::Util::base64_encode", XS_Purple__Util_base64_encode, file, "$");
        (void)newXSproto_portable("Purple::Util::restore_default_signal_handlers", XS_Purple__Util_restore_default_signal_handlers, file, "");
        (void)newXSproto_portable("Purple::Util::base16_decode", XS_Purple__Util_base16_decode, file, "$");
        (void)newXSproto_portable("Purple::Util::base64_decode", XS_Purple__Util_base64_decode, file, "$");
        (void)newXSproto_portable("Purple::Util::quotedp_decode", XS_Purple__Util_quotedp_decode, file, "$");
        (void)newXSproto_portable("Purple::Util::uri_list_extract_uris", XS_Purple__Util_uri_list_extract_uris, file, "$");
        (void)newXSproto_portable("Purple::Util::uri_list_extract_filenames", XS_Purple__Util_uri_list_extract_filenames, file, "$");
        (void)newXSproto_portable("Purple::Util::Str::add_cr", XS_Purple__Util__Str_add_cr, file, "$");
        (void)newXSproto_portable("Purple::Util::Str::binary_to_ascii", XS_Purple__Util__Str_binary_to_ascii, file, "$");
        (void)newXSproto_portable("Purple::Util::Str::has_prefix", XS_Purple__Util__Str_has_prefix, file, "$$");
        (void)newXSproto_portable("Purple::Util::Str::has_suffix", XS_Purple__Util__Str_has_suffix, file, "$$");
        (void)newXSproto_portable("Purple::Util::Str::seconds_to_string", XS_Purple__Util__Str_seconds_to_string, file, "$");
        (void)newXSproto_portable("Purple::Util::Str::size_to_units", XS_Purple__Util__Str_size_to_units, file, "$");
        (void)newXSproto_portable("Purple::Util::Str::to_time", XS_Purple__Util__Str_to_time, file, "$;$$");
        (void)newXSproto_portable("Purple::Util::Date::format_full", XS_Purple__Util__Date_format_full, file, "$");
        (void)newXSproto_portable("Purple::Util::Date::format_long", XS_Purple__Util__Date_format_long, file, "$");
        (void)newXSproto_portable("Purple::Util::Date::format_short", XS_Purple__Util__Date_format_short, file, "$");
        (void)newXSproto_portable("Purple::Util::Markup::extract_info_field", XS_Purple__Util__Markup_extract_info_field, file, "$$$$$$$$$$$$");
        (void)newXSproto_portable("Purple::Util::Markup::find_tag", XS_Purple__Util__Markup_find_tag, file, "$$");
        (void)newXSproto_portable("Purple::Util::Markup::get_tag_name", XS_Purple__Util__Markup_get_tag_name, file, "$");
        (void)newXSproto_portable("Purple::Util::Markup::html_to_xhtml", XS_Purple__Util__Markup_html_to_xhtml, file, "$");
        (void)newXSproto_portable("Purple::Util::Markup::linkify", XS_Purple__Util__Markup_linkify, file, "$");
        (void)newXSproto_portable("Purple::Util::Markup::slice", XS_Purple__Util__Markup_slice, file, "$$$");
        (void)newXSproto_portable("Purple::Util::Markup::strip_html", XS_Purple__Util__Markup_strip_html, file, "$");
        (void)newXSproto_portable("Purple::Util::Markup::get_css_property", XS_Purple__Util__Markup_get_css_property, file, "$$");
        (void)newXSproto_portable("Purple::Util::Markup::unescape_entity", XS_Purple__Util__Markup_unescape_entity, file, "$");
        (void)newXSproto_portable("Purple::Util::fetch_url", XS_Purple__Util_fetch_url, file, "$$$$$$");
        (void)newXSproto_portable("Purple::Util::set_user_dir", XS_Purple__Util_set_user_dir, file, "$");
        (void)newXSproto_portable("Purple::Util::write_data_to_file", XS_Purple__Util_write_data_to_file, file, "$$");
        (void)newXSproto_portable("Purple::Util::set_current_song", XS_Purple__Util_set_current_song, file, "$$$");
        (void)newXSproto_portable("Purple::Util::format_song_info", XS_Purple__Util_format_song_info, file, "$$$$");
        (void)newXSproto_portable("Purple::Util::get_image_extension", XS_Purple__Util_get_image_extension, file, "$");
        (void)newXSproto_portable("Purple::Util::get_image_filename", XS_Purple__Util_get_image_filename, file, "$");
        (void)newXSproto_portable("Purple::Util::read_xml_from_file", XS_Purple__Util_read_xml_from_file, file, "$$");
        (void)newXSproto_portable("Purple::Util::write_data_to_file_absolute", XS_Purple__Util_write_data_to_file_absolute, file, "$$");
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

